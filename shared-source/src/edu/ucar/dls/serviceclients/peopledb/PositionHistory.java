/*
	Copyright 2017 Digital Learning Sciences (DLS) at the
	University Corporation for Atmospheric Research (UCAR),
	P.O. Box 3000, Boulder, CO 80307

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/
package edu.ucar.dls.serviceclients.peopledb;

import java.text.ParseException;
import java.text.SimpleDateFormat;

import edu.ucar.dls.xml.Dom4jUtils;
import edu.ucar.dls.util.MetadataUtils;
import java.util.*;
import java.io.File;

import org.json.JSONObject;
import org.json.JSONArray;

import org.dom4j.*;

/**
 *  Reads an XML document containing people history, and provides ...<p>
 *
 *  The data was created from an iVantage data dump, and correlated with UCAR
 *  upids, which are the keys in the current PeopleDB.
 *
 *@author    Jonathan Ostwald
 */

public class PositionHistory {

	int size = 10000;

	static String iVantageDateFormat = "MM/dd/yy";
	static SimpleDateFormat ivdf = new SimpleDateFormat(iVantageDateFormat);

	Document doc = null;
	File file = null;
	Map personMap = null;


	/**
	 *  Constructor for the PositionHistory object
	 *
	 *@param  source  Description of the Parameter
	 */
	public PositionHistory(String source) {
		file = new File(source);
		try {
			doc = Dom4jUtils.getXmlDocument(file);
		} catch (Exception e) {
			prtln("could not read " + file);
		}

		this.personMap = new HashMap();
		Iterator personIter = doc.getRootElement().elements("person").iterator();
		int cnt = 0;
		while (personIter.hasNext()) {

			Element personEl = (Element) personIter.next();
			String upid = personEl.attributeValue("upid");
			// prtln ("processing " + upid);
			List positions = new ArrayList();
			Iterator posElIter = personEl.elements("position").iterator();
			while (posElIter.hasNext()) {
				Element posEl = (Element) posElIter.next();
				Position pos = new Position(posEl);
				if (!pos.initialized) {
					prtln("could not initialize " + upid);
					pos = null;
					continue;
				} else {
					positions.add(pos);
				}
			}
			positions = this.prunePositionHistory(positions);
			this.personMap.put(upid, positions);

			if (++cnt > +size) {
				break;
			}
		}
		prtln("Position History has data on " + this.personMap.size() + " people");
	}

		/**
	 *  Description of the Method
	 *
	 *@param  dateStr  Description of the Parameter
	 *@return          Description of the Return Value
	 */
	public static Date parseDate(String dateStr) {
		if ("NULL".equals(dateStr) || "-".equals(dateStr)) {
			return new Date();
		}
		try {
			return ivdf.parse(dateStr);
		} catch (Exception e) {
			prtln("parseDate could not parse \"" + dateStr + "\": " + e);
			return new Date(0);
		}
	}

	public static String iVantageDate (Date date) {
		return ivdf.format(date);
	}
	
	/**
	 *  Gets the historyJson attribute of the PositionHistory object
	 *
	 *@return                The historyJson value
	 *@exception  Exception  Description of the Exception
	 */
	public String getHistoryJson() throws Exception {
		throw new Exception("PositionHistory.getHistoryJson not implemented");
	}


	/**
	 *  Description of the Method
	 *
	 *@param  positions  Description of the Parameter
	 */
	private void showPositions(List positions) {
		Iterator posIter = positions.iterator();
		while (posIter.hasNext()) {
			Position pos = (Position) posIter.next();
			prtln(pos.toString());
		}
	}

	private void showUniqueKeys() {
		List uniqueKeys = getUniqueKeys();
		prtln (uniqueKeys.size() + " found");
		for (Iterator i=uniqueKeys.iterator();i.hasNext();) {
			prtln ("- " + (String)i.next());
		}
	}

	/**
	 *  Gets the unique values in the PositionHistory object for a key 
	 generated by the Position instances (e.g., pos.entity + "_" + pos.lab + "_" + pos.org;
	 *
	 *@return    The uniqueKeys value
	 */
	private List getUniqueKeys () {
		List keys = new ArrayList();
		List positionEls = doc.selectNodes ("//position");
		prtln (positionEls.size() + " position nodes found");
		Iterator posElIter = positionEls.iterator();
		while(posElIter.hasNext()) {
			Element element = (Element)posElIter.next();
			Position pos = new Position (element);
			if (!keys.contains(pos.getKey()))
				keys.add (pos.getKey());
		}
		Collections.sort (keys);
		return keys;
	}


	/**
	 *  A unit test for JUnit
	 */
	private static void tester() {
		String data = "C:/Users/ostwald/tmp/POS_HISTORY.xml";
		PositionHistory ph = new PositionHistory(data);
		prtln("instantiated positionHistory");
		String upid = "14005";
		List positions = ph.getPositionHistory(upid);
		prtln("\npositions for upid=" + upid);
		ph.showPositions(positions);

		Position pos = ph.getPosition(upid, "9/29/95");
		prtln("\nfound position: " + pos.toString());
	}


	/**
	 *  The main program for the PositionHistory class
	 *
	 *@param  args           The command line arguments
	 *@exception  Exception  Description of the Exception
	 */
	public static void main(String[] args) throws Exception {
		// String data = "/Users/ostwald/tmp/POS_HISTORY.xml";
		prtln("\n-----------------------------\n");
		// String data = "/Users/ostwald/devel/python/python-lib/ncar_lib/ivantage/POS_HISTORY.xml";
		String data = "C:/Users/ostwald/tmp/POS_HISTORY.xml";
		PositionHistory ph = new PositionHistory(data);

		String upid = "4993";
		String date = null;
		if (args.length > 0) {
			upid = args[0];
			if (args.length > 1) {
				date = args[1];
			}
		}

		prtln ("upid: " + upid);
		List history = ph.getPositionHistory(upid);
		if (history == null) {
			prtln ("nothing found for " + upid);
			return;
		}
		prtln (history.size() + " positions");
		ph.showPositions (history);
		
		if (date != null) {
			prtln ("\nPosition for " + date);
			Position pos = ph.getPosition(upid, date);
			if (pos == null)
				prtln ("position not found!");
			else
				prtln (pos.toString());
		}
		
	}


	/*
	 *  ----------- accessors -------------------
	 */
	/**
	 *  Return the positions for provided upid
	 *
	 *@param  upid  UCAR People ID (e.g., 2457)
	 *@return       The positionHistory value
	 */
	public List getPositionHistory(String upid) {
		return (List) this.personMap.get(upid);
	}


	/**
	 *  Gets the position attribute of the PositionHistory object
	 *
	 *@param  upid  Description of the Parameter
	 *@param  date  Description of the Parameter
	 *@return       The position value
	 */
	public Position getPosition(String upid, String date) {
		return getPosition(upid, parseDate(date));
	}


	/**
	 *  Gets the position attribute of the PositionHistory object
	 *
	 *@param  upid  Description of the Parameter
	 *@param  date  Description of the Parameter
	 *@return       The position value
	 */
	public Position getPosition(String upid, Date date) {
		List positions = this.getPositionHistory(upid);
		if (positions == null) {
			prtln("position history not found for " + upid);
			return null;
		}
		Iterator posIter = positions.iterator();
		while (posIter.hasNext()) {
			Position pos = (Position) posIter.next();
			if ((pos.start_date.before(date) && pos.end_date.after(date)) ||
					pos.start_date.equals(date) || pos.end_date.equals(date)) {
				return pos;
			}
		}
		return null;
	}


	/**
	 *  collapse list of Position by merging chronologically adjacent positions
	 *
	 *@param  positions  list of position Instances
	 *@return            NOT YET DOCUMENTED
	 */
	private List prunePositionHistory(List positions) {
		List pruned = new LinkedList();
		if (positions == null || positions.isEmpty()) {
			return pruned;
		}
		Collections.sort(positions, new PositionComparator());
		String start = null;
		String org_id = null;

		Position prev = null;
		for (Iterator i = positions.iterator(); i.hasNext(); ) {
			Position pos = (Position) i.next();

			if (prev == null) {
				prev = pos;
				continue;
			}
			if (pos.isAdjacentTo(prev)) {
				prev = new Position(prev.start, pos.end, pos.entity, pos.lab, pos.org);
			} else {
				pruned.add(prev);
				prev = pos;
			}
		}
		if (prev != null) {
			pruned.add(prev);
		}
		return pruned;
	}

	/**
	 *  Prints a String with a trailing newline.
	 *
	 *@param  msg  DESCRIPTION
	 */

	static void prtln(String msg) {
		System.out.println(msg);
	}


	/**
	 *  Gets the dateStamp attribute of the PeopleDBTester class
	 *
	 *@return    The dateStamp value
	 */
	static String getDateStamp() {
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
		return sdf.format(new Date());
	}


	/**
	 *  Enable time-based sorting of Position instances
	 *
	 *@author    Jonathan Ostwald
	 */
	public class PositionComparator implements Comparator {

		/**
		 *  Provide comparison for sorting Positions by "start_date" property
		 *
		 *@param  o1  Position 1
		 *@param  o2  Position 2
		 *@return     comparison
		 */
		public int compare(Object o1, Object o2) {
			Date d1;
			Date d2;
			try {
				d1 = ((Position) o1).start_date;
				d2 = ((Position) o2).start_date;
			} catch (Exception e) {
				prtln("Error: unable to compare start_dates: " + e.getMessage());
				return 0;
			}
			return d1.compareTo(d2);
		}
	}

}


